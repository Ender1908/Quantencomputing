<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Quantencomputing - Store Now Decrypt later</title>
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1">
    <!-- Based on a poster template from https://github.com/cpitclaudel/academic-poster-template -->


    <link rel="stylesheet" type="text/css" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="assets/css/core.css">
    <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans+Condensed:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&amp;family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap"
          rel="stylesheet">

    <style>
        html {
            font-size: 1.15rem
        }
    </style>
</head>

<body vocab="http://schema.org/" typeof="ScholarlyArticle">
<header role="banner" class="c_banner">

    <div class="c_headlines">
        <h1 property="headline">Store Now, Decrypt Later</h1>
        <h2 property="alternativeHeadline">Quantencomputing</h2>
        <address>
            <a property="author">WWI21KI</a>
            <br/><a property="sourceOrganization" href="https://heidenheim.dhbw.de" target="_blank">DHBW Heidenheim</a>
        </address>
    </div>
    <div class="c_picture">
        <aside>
            <a href="https://www.heidenheim.dhbw.de/startseite" target="_blank"><img style="background: white"
                                                                                     src="assets/images/Logo.png"
                                                                                     alt="DHBW Heidenheim Logo"></a>

        </aside>
    </div>
</header>

<main property="articleBody" id="mainBody">

    <!--Einführung-->
    <article property="abstract">
        <header><h3>Einführung / Relevanz</h3></header>
        <p>
            Quantencomputer sind eine vielversprechende Entwicklung in der Welt der Informationstechnologie. Sie nutzen Prinzipien der Quantenmechanik, und ermöglichen es daher mathematische Probleme effizienter zu lösen? Gleichzeitig bringen sie auch erhebliche Sicherheitsbedenken mit sich, da sie bspw. das RSA-Verschlüsselungsverfahren entschlüsseln können. [1]
        </p>
        <p>
            Eine besonders große Bedrohung stellt dabei das "Store Now, Decrypt Later" Prinzip dar.
        </p>
    </article>


    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#why">
        <header class="c_popup">
            <div>
                <h3>Store Now, Decrypt Later</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            Verschlüsselte Daten werden schon heute gesammelt, um sie zu entschlüsseln, sobald leistungsfähige Quantencomputer einsatzfähig sind. Dies wird auch "Store Now, Decrypt Later" genannt.[2]
        </p>


    </article>


    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#rsa">
        <header class="c_popup">
            <div>
                <h3>RSA</h3>
            </div>
            <div>
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            Das RSA-Verfahren wurde in den 1970er Jahren von den Wissenschaftlern Ron Rivest, Adi Shamir und Len Adleman entwickelt. [3] Es ist ein Verschlüsselungsverfahren, welches auf dem Faktorisierungsproblem basiert. [4]
        </p>


    </article>

    <article>
        <header><h3>Algorithmen</h3></header>
        <div>
            <p>
                Peter Shor entwickelte im Jahre 1994 einen Algorithmus, welcher das Faktorisierungsproblem lösen kann. Dieser ist heute als "Shor Algorithmus" bekannt. Der Alogirthmus ist in der Lage, die Primfaktoren einer Zahl zu berechnen. [8]
            </p>
            <p>
                Hierbei wird der euklidischer Algorithmus benötigt.
            </p>
        </div>
        <hr>
        <div class="c_modal c_popup" data-bs-toggle="modal" data-bs-target="#euklAlgorithmus">
            <div>
                Euklidischer Algorithmus
            </div>
            <div>
                <img src="assets/images/open_in_new_black.png" alt="Pop-Up">
            </div>
        </div>
        <hr>
        <div class="c_modal c_popup" data-bs-toggle="modal" data-bs-target="#shorAlogrithmus">
            <div>
                Shor Alogrithmus
            </div>
            <div>
                <img src="assets/images/open_in_new_black.png" alt="Pop-Up">
            </div>
        </div>
        <hr>
        <div class="c_modal c_popup" data-bs-toggle="modal" data-bs-target="#example">
            <div>
                Beispiel
            </div>
            <div>
                <img src="assets/images/open_in_new_black.png" alt="Pop-Up">
            </div>
        </div>
    </article>


    <figure style="flex-grow: 9999999">
        <img src="assets/images/00010-182089029.png" alt="cybersecurity" />
    </figure>


    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#quantencomputer">
        <header class="c_popup">
            <div>
                <h3>Quantencomputer</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            Ein Quantencomputer basiert auf Quantenmechanik und nutzt Qubits anstelle herkömmlicher Bits. Qubits können im Gegensatz zu klassischen Bits den Zustand 0, 1 oder eine Superposition aus beiden gleichzeitig annehmen. [12]
        </p>
    </article>



    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#quantencomputerChanges">
        <header class="c_popup">
            <div>
                <h3>Auswirkungen von Quantencomputern</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>


        <p>
            Aktuelle Computer können theoretisch RSA-Schlüssel entschlüsseln, doch die Berechnungen dauern lange, z. B. 300 Billionen Jahre für einen 2048-Bit-Schlüssel. Daher gilt RSA als sicher. Zukünftige Quantencomputer könnten jedoch durch den Shor Algorithmus diese Zeit drastisch verkürzen, z. B. auf 10 Sekunden für einen 2048-Bit-Schlüssel mit einem 4099-Qubit-Quantencomputer. Das würde den heutigen RSA-Verschlüsselungsstandard unsicher machen. [13]
        </p>
    </article>

    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#whatToDoAgainst">
        <header class="c_popup">
            <div>
                <h3>Was kann man dagegen tun?</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            Die Post-Quanten-Kryptografie umfasst Verfahren, die selbst von Quantencomputern nicht gebrochen werden können. Dies beinhaltet codebasierte, gitterbasierte und hashbasierte Kryptografie sowie die Methode Perfect Forward Secrecy (PFS). PFS nutzt das Diffie-Hellman-Verfahren, um Sitzungsschlüssel auszutauschen, die nach der Kommunikation gelöscht werden. Dadurch bleibt Entschlüsselung trotz bekanntem privatem Schlüssel unmöglich. PFS bietet hohe Sicherheit, erfordert jedoch leistungsfähigere Hardware und längere Schlüsselerzeugung und SSL-Handshakes, besonders für Server mit vielen Verbindungen. [14]
        </p>
    </article>

    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#summary">
        <header class="c_popup">
            <div>
                <h3>Zusammenfassung</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            Die Weiterentwicklung von Quantencomputern könnte die aktuellen Sicherheitsstandards gefährden, insbesondere RSA-Verschlüsselungen. Daher ist die Entwicklung und Implementierung quantensicherer Verschlüsselungsmethoden dringend erforderlich.
        </p>
    </article>

    <article class="c_modal" data-bs-toggle="modal" data-bs-target="#sources">
        <header class="c_popup">
            <div>
                <h3>Quellen</h3>
            </div>
            <div style="margin-left: auto">
                <img src="assets/images/open_in_new_white.png" alt="Pop-Up">
            </div>
        </header>
        <p>
            In diesem Abschnitt werden die Quellen aufgelistet, welche für die Erstellung dieses Poster verwendet wurden.
        </p>
    </article>

    <!--Pop-ups-->
    <!-- Button trigger modal -->

    <!--Modal Warum betrifft es uns?-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="why" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="whyLabel">Store Now, Decrypt Later</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Da Quantencomputer die aktuell genutzte Verschlüsselung entschlüsseln können, stellt das „Store Now, Decrypt Later" - Prinzip (auch „Harvest now, decrypt later“ genannt) ein besonders großes Problem dar. Dabei werden bereits heute Daten in großem Maße abgegriffen und gespeichert, um diese in Zukunft mit der Verwendung von Quantencomputern zu entschlüsseln. Unbefugte Personen können so in Zukunft an sensible Daten, wie zum Beispiel Gesundheitsdaten, Patente, Firmengeheimnisse oder ähnliches kommen. [2]
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal RSA-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="rsa" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="rsaLabel">Die RSA-Verschlüsselung</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Das RSA-Verfahren wurde in den 1970er Jahren von den Wissenschaftlern Ron Rivest, Adi Shamir und Len Adleman entwickelt. Diese sind auch für die Namensgebung,
                        <span class="fw-bold">R</span>ivest <span class="fw-bold">S</span>hamir <span
                            class="fw-bold">A</span>dleman – Verfahren verantwortlich. Das Ziel ihrer Arbeit war es, eine Methode zu entwickeln, um einerseits Nachrichten privat zu versenden und andererseits Nachrichten digital signieren zu können. In ihrer Arbeit zeigten sie auch, wie man dies in ein elektronisches Postsystem integrieren könnte. Die Grundlage für ihre Arbeit lieferten Diffie und Hellmann, welche ein sogenanntes „public-key cryptography“ entwickelten. [3]
                    </p>
                    <p>
                        Das Grundprinzip der RSA-Verschlüsselung ist demnach einen privaten und öffentlichen Schlüssel zu bilden. Hierfür wählt man zwei sehr große Primzahlen p und q, welche der gleichen Größenordnung entsprechen und berechnet deren Produkt. [4]
                    </p>
                    <p>
                        \[ n = p \cdot q \]
                    </p>
                    <p>
                        \(n\) ist der öffentliche Schlüssel
                    </p>
                    <p>
                        \(p\) und \(q\) sind die privaten Schlüssel
                    </p>
                    <p>
                        Die Sicherheit der RSA–Verschlüsselung beruht darauf, dass es einfach ist, den öffentlichen Schlüssel zu bilden, aber es jedoch nahezu unmöglich ist den privaten Schlüssel anhand des öffentlichen zu berechnen [6]. Dies nennt man Faktorisierungsproblem [5].
                    </p>
                    <p>
                        Der öffentliche Schlüssel wird für die Verschlüsselung verwendet und muss nicht geheimgehalten werden. Der private Schlüssel hingegen muss geheimgehalten werden und wird für die Entschlüsselung verwendet. Zur Verschlüsselung einer Nachricht wird der öffentliche Schlüssel des Empfängers verwendet. Die Nachricht wird je nach deren Länge in Blöcke aufgeteilt. Jeder dieser Blöcke wird durch den öffentlichen Schlüssel verschlüsselt. Nun kann diese verschlüsselte Nachricht an den Empfänger gesendet werden. Der Empfänger kann dann die verschlüsselte Nachricht entschlüsseln. Hierfür muss er seinen privaten Schlüssel verwenden. Durch die RSA–Verschlüsselung kann die Nachricht nur mit dem entsprechenden privaten Schlüssel entschlüsselt werden. [6]
                    </p>
                    <p>
                        Mit dem heutigen Stand der Technik ist es, wie oben erwähnt, unmöglich den öffentlichen Schlüssel n ohne den privaten Schlüssel p und q in dessen Primfaktoren zu zerlegen. Damit dies der Fall ist empfiehlt das Bundesamt für Sicherheit in der Informationstechnik eine Mindestbitlänge von 3000 Bits. Dies garantiert die Sicherheit von RSA. [7]
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Euklidischer Algorithmus-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="euklAlgorithmus" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Euklidischer Algorithmus</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Der Euklidischer Algorithmus wird genutzt um den größten gemeinsamen Teiler zu ermitteln. Die Funktionsweise ist folgende:
                    </p>
                    <ol>
                        <li>
                            Zunächst wird \(a\) durch \(b\) geteilt, um den Rest der Division zu erhalten. Ist der Rest gleich \(0\) ist \(b\) bereits der größte gemeinsame Teiler. Falls der Rest nicht gleich \(0\) ist so wird \(b\) durch den Rest geteilt.
                        </li>
                        <li>
                            Nun werden diese Schritte so oft ausgeführt bis der Rest gleich null ergibt. [9]
                        </li>
                    </ol>
                    <p>Beispiel: größter gemeinsamer Teiler von \(77\) und \(8\) \(( \text{ggT}(77, 8))\)</p>
                    \(77 / \) <span class="highlight">\(8\)</span> \( = 9 Rest \) <span
                        class="highlight">\(5\)</span><br>
                    <span class="highlight">\(8\)</span> \( / \) <span class="highlight">\(5\)</span> \( = 1 Rest \)
                    <span>\( 3 \)</span><br>


                    <table class="table table-bordered">
                        <thead>
                        <tr>
                            <th scope="col">\(a\)</th>
                            <th scope="col">\(b\)</th>
                            <th scope="col">\(Ergebnis\)</th>
                            <th scope="col">\(Rest\)</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>\(77\)</td>
                            <td>\(8\)</td>
                            <td>\(9\)</td>
                            <td>\(5\)</td>
                        </tr>
                        <tr>
                            <td>\(8\)</td>
                            <td>\(5\)</td>
                            <td>\(1\)</td>
                            <td>\(3\)</td>
                        </tr>
                        <tr>
                            <td>\(5\)</td>
                            <td>\(3\)</td>
                            <td>\(1\)</td>
                            <td>\(2\)</td>
                        </tr>
                        <tr>
                            <td>\(3\)</td>
                            <td>\(2\)</td>
                            <td>\(1\)</td>
                            <td>\(1\) ← Größter gemeinsamer Teile</td>
                        </tr>
                        <tr>
                            <td>\(2\)</td>
                            <td>\(1\)</td>
                            <td>\(1\)</td>
                            <td>\(0\)</td>
                        </tr>


                        </tbody>
                    </table>

                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal Shor Algorithmus-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="shorAlogrithmus" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="shorAlogrithmusLabel">Shor Algorithmus</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Der Shor Algorithmus wurde im Jahre 1994 entwickelt</p>
                    <ol>
                        <li>
                            Zunächst wird eine zufällige Zahl \( m \) ausgewählt, welche kleiner ist als n (\(m < n \)). Mit Hilfe des Euklidischen Algorithmus wird der ggT ermitteln. Ist dieser Teiler gleich 1 so wird mit Schritt 2 fortgefahren. Ist der größte gemeinsame Teiler nicht gleich 1 so ist das Problem bereits gelöst und eine der Primzahlen wurde ermittelt. [10]
                        </li>
                        <li>
                            Anschließend muss die Periode \(P\) ermittelt werden. Um diese Periode herauszufinden, wird die zufällig ausgewählte Zahl \(m\) potenziert und anschließen mit dem Modulo n berechnet (\(m^x \pmod{n}\)). Dieser Schritt wird so oft wiederholt, bis das Ergebnis gleich 1 ist. Die Anzahl der Wiederholungen ist \(P\). [11]
                        </li>
                        <li>
                            Wurde die Periode gefunden muss nun überprüft werden, ob die Periode eine gerade oder ungerade Zahl ist. Ist die Zahl gerade kann mit dem nächsten Schritt fortgefahren werden. Ist die Zahl ungerade muss mit einer neuen Zahl in Schritt 1 begonnen.
                        </li>
                        <li>
                            Im Anschluss wird überprüft, ob \(m^{\frac{P}{2}} + 1 \neq 0 \pmod{n}\) ist. Trifft dies zu, so wird mit Schritt 5 fortgefahren. Ist dies nicht der Fall muss mit einer neuen Zahl \(m\) in Schritt 1 begonnen werden.
                        </li>
                        <li>
                            Zuletzt wird nun der ggT von \( \text{ggT}(m^{\frac{P}{2}} + 1, n) \) mittels dem Euklidischen Algorithmus ermittelt. Das Ergebnis von dieser Rechnung ist nun einer der Primfaktoren \( p \) oder \( q \), aus welcher \(n\) besteht. [10]
                        </li>
                    </ol>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal Beispiel-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="example" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleLabel">Beispiel</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Zunächst wird eine Zahl \(n\) ausgewählt, welche aus zwei Primzahlen \(p\) und \(q\) besteht.
                    </p>
                    <p>
                        \[ p \cdot q = 7 \cdot 13 = 91 \]
                    </p>
                    <ol>
                        <li>
                            <p>Es wird eine zufällige Zahl \( m \) ausgewählt. Diese Zahl muss kleiner als \(n\) sein. In diesem Beispiel wird die Zahl \(m = 3\) ausgewählt.</p>
                            <p>Außerdem wird mithilfe des Euklidische Algorithmuses bestimmt der ggT der beiden Zahlen bestimmt.
                                \[ \text{ggT}(m, n) = \text{ggT}(3, 91) = 1 \]</p>
                            <table class="table table-bordered">
                                <thead>
                                <tr>
                                    <th scope="col">\(a\)</th>
                                    <th scope="col">\(b\)</th>
                                    <th scope="col">\(Ergebnis\)</th>
                                    <th scope="col">\(Rest\)</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>\(91\)</td>
                                    <td>\(3\)</td>
                                    <td>\(30\)</td>
                                    <td>\(1\) ← Größter gemeinsamer Teile</td>
                                </tr>
                                <tr>
                                    <td>\(3\)</td>
                                    <td>\(1\)</td>
                                    <td>\(3\)</td>
                                    <td>\(0\)</td>
                                </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>
                            <p>Im 2. Schritt wird nun die Periode \(P\) herausgefuden. Dies wird mit Hilfe folgender Fromel gelöst: \(m^x \pmod{n}\)</p>
                            <table class="table table-bordered">
                                <thead>
                                <tr>
                                    <th scope="col">\(m\)</th>
                                    <th scope="col">\(Ergebnis\)</th>
                                    <th scope="col">\( \pmod{n} \)</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>\(3^0\)</td>
                                    <td>\(1\)</td>
                                    <td>\(1\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^1\)</td>
                                    <td>\(3\)</td>
                                    <td>\(3\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^2\)</td>
                                    <td>\(9\)</td>
                                    <td>\(9\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^3\)</td>
                                    <td>\(27\)</td>
                                    <td>\(27\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^4\)</td>
                                    <td>\(81\)</td>
                                    <td>\(81\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^5\)</td>
                                    <td>\(243\)</td>
                                    <td>\(61\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^6\)</td>
                                    <td>\(729\)</td>
                                    <td>\(1\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^7\)</td>
                                    <td>\(2187\)</td>
                                    <td>\(3\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^8\)</td>
                                    <td>\(6561\)</td>
                                    <td>\(9\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^9\)</td>
                                    <td>\(19683\)</td>
                                    <td>\(27\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^{10}\)</td>
                                    <td>\(59049\)</td>
                                    <td>\(81\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^{11}\)</td>
                                    <td>\(177147\)</td>
                                    <td>\(61\)</td>
                                </tr>
                                <tr>
                                    <td>\(3^{12}\)</td>
                                    <td>\(531441\)</td>
                                    <td>\(1\)</td>
                                </tr>
                                </tbody>
                            </table>
                            <p>Es ist zu erkennen, dass die Periode \(P = 6\).</p>
                        </li>
                        <li>
                            Im nächsten Schritt wird überprüft, ob die Periode \(P = 6\) gerade ist. Da die Periode gerade ist, kann mit Schritt 4 fortgefahren werden.
                        </li>
                        <li>
                            <p>
                                Weitergehend wird überprüft, ob \(m^{\frac{P}{2}} + 1 \neq 0 \pmod{n}\) ist.
                                \[m^{\frac{P}{2}} + 1 = 3^{\frac{6}{2}} + 1 = 28 = 0 \pmod{28}, \quad \text{folglich nicht} \neq 0 \pmod{91}\]
                            </p>


                        </li>
                        <li>
                            <p>
                                \(\text{ggT}\left(3^{\frac{6}{2}} + 1, 91\right) = \text{ggT}\left(28, 91\right)\)
                            </p>
                            <table class="table">
                                <thead>
                                <tr>
                                    <th scope="col">\(a\)</th>
                                    <th scope="col">\(b\)</th>
                                    <th scope="col">\(Rest\)</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>\(91\)</td>
                                    <td>\(28\)</td>
                                    <td>\(7\) ← Größter gemeinsamer Teile bzw. \(q\)</td>
                                </tr>
                                <tr>
                                    <td>\(28\)</td>
                                    <td>\(7\)</td>
                                    <td>\(0\)</td>
                                </tr>
                                </tbody>
                            </table>
                        </li>
                    </ol>

                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>


    <!--Modal Quantencomputer-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="quantencomputer" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="quantencomputerAlogrithmusLabel">Quantencomputer</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Ein Quantencomputer fundiert auf den Prinzipien der Quantenmechanik und unterscheidet sich von traditionellen Computern durch die Verwendung von Quantenbits oder Qubits anstelle herkömmlicher Bits. Quantenbits, oft auch als Qubits abgekürzt, sind die grundlegenden Informationseinheiten in der Quantencomputertechnologie. Im Gegensatz zu den Qubits stehen die klassischen Bits, die in der heutigen Zeit Standard in der Informationstechnik sind. Diese herkömmlichen Bits können nur die beiden Werte 0 oder 1 annehmen. Ein Qubit wiederum kann sich nach dem Superpositionsprinzip in einer Linearkombination in mehreren Zuständen gleichzeitig befinden. Dies wird daher auch Superposition genannt. Qubits können somit nicht nur die eindeutigen Zustände 0 oder 1 besitzen, sondern auch eine Überlagerung dieser beiden Zustände. [12]
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal was ändern quantencomputer daran-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="quantencomputerChanges" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="quantencomputerChangesLabel">Auswirkungen von Quantencomputern</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Um beispielsweise einen RSA-Schlüssel zu entschlüsseln, wird nicht unbedingt ein Quantencomputer benötigt. Die Entschlüsselung wäre theoretisch auch mit den aktuellen technischen Mitteln möglich. Jedoch benötigen die Berechnungen eines solchen Entschlüsselungsverfahren viel Zeit, bis diese Computer zu einer Lösung kommen bzw. den privaten Schlüssel berechnet haben. Ein klassischer Computer benötigt zum Beispiel 300 Billionen Jahre um einen privaten RSA-2048 Bit Schlüssel über den öffentlichen Schlüssel zu entschlüsseln. Aus diesem Grund zählt diese Verschlüsselungsart heutzutage als sicher, da es verhältnismäßig viel zu lange dauert, um an die verschlüsselten Daten zu gelangen. Dies können Quantencomputer in der Zukunft theoretisch ändern. Durch den Shor Algorithmus ist es möglich, die Komplexität der Berechnung des privaten Schlüssels deutlich zu minimieren. Konkret erleichtert dieser das Herausfinden der Periode \(P\). Dies ist beim RSA-Verschlüsselungsverfahren möglich, da es sich um eine asymmetrische Verschlüsselung mit Basis der Primzahlmultiplikation handelt. Diese Zahlen sind je nach Algorithmus sehr groß (bspw. 2048 Bit Schlüssel) und somit mit heutigen Computern und deren Rechenleistung nur schwer zurückzurechnen. Ein Quantencomputer mit 4099 stabilen Qubits könnte theoretisch einen RSA-2048 Schlüssel innerhalb von 10 Sekunden entschlüsseln, anstatt den momentanen notwendigen 300 Billionen Jahren. Dadurch wäre der heute heutige Verschlüsselungsstandard RSA im Web nicht mehr sicher genug. [13]
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal was kann man dagegen tun-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="whatToDoAgainst" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="whatToDoAgainstLabel">Was kann man dagegen tun?</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Die Post-Quanten-Kryptografie besteht aus kryptografische Verfahren, von denen angenommen wird, dass sie auch durch einen Quantencomputer nicht berechnet werden können. Darunter ist zum Beispiel die Codebasierte Kryptografie, die auf der Schwierigkeit beruht, fehlerkorrigierende Codes effizient zu dekodieren. Ein weiteres Verfahren ist die gitterbasierte Kryptografie, durch ihre Schwierigkeit mit bestimmten Problemen in mathematischen Gittern, also Gitter oder Raster die in einem mehrdimensionalen Raum existieren und aus Punkten oder Vektoren bestehen, die gleichmäßig im Raum verteilt sind. Die hashbasierte Kryptografie ist ebenfalls ein sicheres Verfahren, das auf kryptografischen Hashfunktionen basiert. [14]
                    </p>
                    <p>
                        Ein weiteres Verfahren ist die Perfect forward Secrecy (PFS) Methode. PFS ist für den Schlüsselaustausch in einem kryptografischen Verfahren entwickelt worden, um die nachträgliche Entschlüsselung durch Bekanntwerden des privaten Schlüssels zu verhindern. Dabei kommen sogenannte Sitzungsschlüssel zum Einsatz. Nach dem Austausch der Daten und Beendigung der Sitzung werden auf beiden Seiten die Sitzungsschlüssel unwiderruflich gelöscht. Wenn dies ordnungsgemäß auf beiden Seiten durchgeführt wurde, ist auch trotz Bekanntgabe des privaten Schlüssels nach Beendigung der Sitzung keine Entschlüsselung der Daten möglich. Die PFS Methode verwendet das so genannte Diffie-Hellman-Verfahren, das dafür sorgt, dass die Sitzungsschlüssel nicht übertragen werden müssen und somit auch nicht von einer unberechtigten Person abgefangen werden können. Der Vorteil ist, dass PFS deutlich mehr Sicherheit vor nachträglicher Entschlüsselung bietet. Nachteil ist jedoch, dass das Diffie-Hellman-verfahren höhere Anforderungen an die Computersysteme und deren Rechenleistung hat. Die Schlüsselerzeugung und der SSL-Handshake benötigten deutlich mehr Zeit. Dadurch ist vor allem bei den Servern leistungsfähigere Hardware notwendig, da diese viele verschiedene Verbindungen aufrechterhalten müssen. [15]
                    </p>
                    <p>
                       Des Weiteren existieren Standardisierungsaktivitäten im Bereich quantischer Kryptogrrafie, insbesondere das Post-Quantum-Cryptography Project des US-amerikanischen National Institute of Standards and Technology (NIST). Dieses Projekt befasst sich in mehreren Runden mit eingereichten Kryptografie-Verfahren, die innerhalb dieses Projekts untersucht werden. Als Ergebnis werden neue Verfahren standardisiert. [14]
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal summary-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="summary" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="summaryLabel">Zusammenfassung</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>
                        Zusammenfassend ist festzustellen, dass die aktuell genutzten Sicherheitsstandards durch die Weiterentwicklungen von Technologien, wie bspw. Quantencomputern, zukünftig nicht mehr sicher sind. Speziell wenn das Prinzip von „Store Now, Decrypt Later“ genauer betrachtet wird. Das Verschlüsselungsverfahren RSA kann mittels des Shor Algorithmus und Quantencomputer entschlüsselt werden und somit Zugriff auf die verschlüsselten Daten ermöglichen. Aus diesem Grund ist es wichtig, dass ein Bewusstsein geschaffen wird, dass aktuelle Verschlüsselungsverfahren in Zukunft nicht sicher sind. Aus diesem Grund müssen schon heute neue quantensichere Verschlüsselungsverfahren entwickelt und implementiert werden.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>

    <!--Modal sources-->
    <div class="modal modal-xl fade .modal-dialog-scrollable" id="sources" tabindex="-1"
         aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="sourcesLabel">Quellen</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <ol class="custom-list">
                        <li>
                            Hagemeier, Heike (2019): Kryptografie – heute und zukünftig. In: Datenschutz Datensich 43 (10), S. 631–635.
                        </li>
                        <li>
                            Barenkamp, Marco (2022): „Steal Now, Decrypt Later“. In: Informatik Spektrum 45 (6), S. 349–355. DOI: 10.1007/s00287-022-01474-z, Seite 349.
                        </li>
                        <li>
                            Rivest, R. L.; Shamir, A.; Adleman, L. (1978): A method for obtaining digital signatures and public-key cryptosystems. In: Commun. ACM 21 (2), S. 120–126. DOI: 10.1145/359340.359342, Seite 120.
                        </li>
                        <li>
                            Walz, Guido (2023): Das RSA-Verfahren. In: Das RSA-Verfahren: Verschlüsseln und Entschlüsseln auf Basis der Algebra: Springer Spektrum, Berlin, Heidelberg, S. 25–40. Online verfügbar unter https://link.springer.com/chapter/10.1007/978-3-662-67363-8_2, Seite 25-30.
                        </li>
                        <li>
                            Rothe, Jörg (2008): Komplexitätstheorie und Kryptologie. Eine Einführung in Kryptokomplexität. Berlin, Heidelberg: Springer Berlin Heidelberg (eXamen.press). Online verfügbar unter http://nbn-resolving.org/urn:nbn:de:bsz:31-epflicht-1592226.
                        </li>
                        <li>
                            Banoth, Rajkumar; Regar, Rekha (2023): Classical and Modern Cryptography for Beginners. 1st ed. 2023. Cham: Springer Nature Switzerland; Imprint Springer. Seite 119-126.
                        </li>
                        <li>
                            Bundesamt für Sicherheit in der Informationstechnik: BSI-TR-02102. Online verfügbar unter https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile&v=9, Seite 39-41, Zugriff am 30.08.2023.
                        </li>
                        <li>
                            Tsihrintzis, George A. (Hg.) (2020): 2020 IEEE 5th International Conference on Computing Communication and Automation (ICCCA). Galgotias University, Greater Noida, UP, India, Oct 30-31, 2020. Unter Mitarbeit von Pradeep Kumar. 2020 IEEE 5th International Conference on Computing Communication and Automation (ICCCA). Greater Noida, India, 10/30/2020 - 10/31/2020. Institute of Electrical and Electronics Engineers. Piscataway, NJ: IEEE, Seite 91.
                        </li>
                        <li>
                            Oswald, Nicola; Steuding, Jörn (2015): Elementare Zahlentheorie. Ein sanfter Einstieg in die höhere Mathematik. Berlin, Heidelberg: Springer Berlin Heidelberg (Springer-Lehrbuch), Seite 66 f.
                        </li>
                        <li>
                            Ugwuishiwu, C. H.; Orji, U. E.; Ugwu, C. I.; Asogwa, C. N. (2020): An overview of Quantum Cryptography and Shor’s Algorithm. In: IJATCSE 9 (5), S. 8397–8405. DOI: 10.30534/ijatcse/2020/214952020, Seite 7492 f.
                        </li>
                        <li>
                            Tsihrintzis, George A. (Hg.) (2020): 2020 IEEE 5th International Conference on Computing Communication and Automation (ICCCA). Galgotias University, Greater Noida, UP, India, Oct 30-31, 2020. Unter Mitarbeit von Pradeep Kumar. 2020 IEEE 5th International Conference on Computing Communication and Automation (ICCCA). Greater Noida, India, 10/30/2020 - 10/31/2020. Institute of Electrical and Electronics Engineers. Piscataway, NJ: IEEE, Seite 93.
                        </li>
                        <li>
                            Mainzer, Klaus (2020): Quantencomputer. Von der Quantenwelt Zur Künstlichen Intelligenz. Berlin, Heidelberg: Springer Berlin / Heidelberg. Online verfügbar unter https://ebookcentral.proquest.com/lib/kxp/detail.action?docID=6450944, Seite 55 ff.
                        </li>
                        <li>
                            Breaking RSA Encryption - an Update on the State-of-the-Art - QuintessenceLabs (2023). Online verfügbar unter https://www.quintessencelabs.com/blog/breaking-rsa-encryption-update-state-art, Zugriff am 28.08.2023.
                        </li>
                        <li>
                            Bundesamt für Sicherheit in der Informationstechnik (2023): Post-Quanten-Kryptografie. Online verfügbar unter https://www.bsi.bund.de/DE/Themen/Unternehmen-und-Organisationen/Informationen-und-Empfehlungen/Quantentechnologien-und-Post-Quanten-Kryptografie/Post-Quanten-Kryptografie/post-quanten-kryptografie_node.html, Zugriff am 28.08.2023.
                        </li>
                        <li>
                            Schmitz, Peter; Luber, Stefan (2017): Was ist Perfect Forward Secrecy (PFS)? In: Security-Insider, 27.12.2017. Online verfügbar unter https://www.security-insider.de/was-ist-perfect-forward-secrecy-pfs-a-673063/, Zugriff am 28.08.2023.
                        </li>
                    </ol>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Schließen</button>
                </div>
            </div>
        </div>
    </div>


</main>


<!--Footer-->
<footer>

    <address class="monospace"> Quantencomputing &middot; WWI21KI DHBW Heidenheim &middot; 1524040 &middot; 3800936 &middot; 4557700 &middot; 6615089</address>

    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
    <script src="assets/javascript/scroll.js"></script>
</footer>
</body>
</html>